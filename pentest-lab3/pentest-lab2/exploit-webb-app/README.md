 # this is a good chunk of information here. an opportunity to learn a grip. lets get it!! : )


''


here is what our goal is in this folder..


    Launch a SQL Injection Attack
    Perform Broken Authentication Attacks
    View Session ID in URL
    Conduct OS Command Injection Attack
    Perform Server-side Includes Injection Attack (SSI)
    Perform Cross-site Scripting Attack
    Performing Directory Traversal Attack
    Perform Web Application Brute Forcing Using DirBuster
    Know about Lack of Input Validation
    Explain Hard-code Credentials
    Know about Data in Cleartext Format
    Know about Source Code Comments
    Explain Verbose Errors
    Know about Lack of Error Handling
    Know about Lack of Code Signing
    Explain the Occurrence of Race Conditions
    Know about Hidden Elements - Sensitive Information in the DOM

''

relavence to test: PT0-001: 3.4 Given a scenario, exploit application-based vulnerabilities



Exploit Web Application Vulnerabilities

In many scenarios, organizations use off-the-shelf applications. In other scenarios, the organizations use a mix of off-the-shelf and custom applications. The patches and updates for the off-the-shelf applications are created and released by the vendor that created the application. It is now the organization's responsibility to update their existing off-the-shelf applications to patch these applications. In the case of custom applications, this is not the scenario. The custom applications are developed to meet a specific business need. An organization may have an in-house development team to create the application, or it might be outsourced to another vendor. Releasing updates is a common issue with custom applications. The vendors do not provide updates in most cases. Therefore, these inherent vulnerabilities will continue to be present until the time application is used.

There are several known Web application vulnerabilities. Open Web Application Security Project, more commonly known as OWASP, releases the top 10 Web application vulnerabilities, which are released after every few years. This data is collected from various organizations through extensive research, and then top 10 Web applications are selected. Remember - there are hundreds of Web application vulnerabilities, and therefore, when doing a penetration test, you can focus on the key ones but do not ignore to test for the other vulnerabilities. The top 10 Web application vulnerabilities of 2017 released by OWASP are:

    A1:2017-Injection
    A2:2017-Broken Authentication
    A3:2017-Sensitive Data Exposure
    A4:2017-XML External Entities (XXE)
    A5:2017-Broken Access Control
    A6:2017-Security Misconfiguration
    A7:2017-Cross-Site Scripting (XSS)
    A8:2017-Insecure Deserialization
    A9:2017-Using Components with Known Vulnerabilities
    A10:2017-InsufficientLogging&Monitoring

This module will cover a few of these vulnerabilities that you can exploit.
Note: In this module, you will use a Web application named bWAPP, which is designed with more than 200 vulnerabilities. It is not legal to exploit a live Web application on the Internet, and therefore, you will use this Web application to learn the art of exploiting a Web application. It will not be possible to cover all types of vulnerabilities due to the short time in the lab environment.


ALERT!!!!!!!!Here are some odds and end I didnt really have a home for!!!!!!!!!

''

sing Insecure Code Practices

Applications fall prey to the hackers because of poor coding practices followed by the developers. Whether it is a desktop or a Web application, developers often forget that a small error, such as leaving sensitive information in the comments section, can lead to the application compromise. Any type of insecure coding practice, such as hard-coded credentials or lack of error handling, introduces vulnerabilities in an application. Once the attacker has discovered the vulnerability and found a way to exploit it, the attacker can compromise the application easily.

With insecure code practices, no application can be considered secure. Attackers will always look out for vulnerabilities in the application to compromise the confidentiality, integrity, or availability of the data held by the application.

In this exercise, you will learn about insecure code practices.

''

nput Validation

Input validation is a basic requirement of any type of application. However, the lack of input validation is the most common mistake committed by the developers. Input validation is a method that should validate the data before it is submitted to the application.

When not implemented properly, several vulnerabilities can be introduced in the system, such as:

    Interpreter Injection
    SQL Injection
    Null Byte Injection
    Scripting attacks
    Locale/Unicode attacks
    File system attacks
    Buffer overflows
    Uncontrolled format string
    Directory traversal

Input validation is the first line of defence in any application. If you do not implement proper input validation, you are just allowing the attacker to get into your application and then putting the data at risk. If you implement proper data validation, you are making it difficult for the attacker to get into the application with a malicious or jargon code. For example, you have a Range column in a form. If you do not validate the input, the attacker can put any number that the application may not be able to handle. The attacker may put 10101010101010 as the value. Rather than leaving it without any validation, you can validate that the Value field will accept only numbers and between the range of 1 to 99, which means a maximum of two numbers are allowed. If the attacker attempts 100, the value is not accepted. You can restrict entry to only two values, and the third one is not accepted.
Hard-code Credentials

Hard-coded credentials are often stored within the application for a purpose. Developers can use these hard-coded credentials if the application is locked out due to some reason. The developers then have the hard-coded credentials that can be used to gain access to the application. The hard-code credentials are referred to as a backdoor, which, if found by an attacker, can compromise the entire application and its data.

There are two types of hard-coded credentials:

    Inbound: Used for accessing the Web application. The credentials can be recovered from gaining access to the source code or through the brute-force attack.
    Outbound: Used for accessing the back-end database. The credentials are stored in the database in plain-text format. After the attacker has control of the application, the credentials can be retrieved from the database.

Data in Cleartext Format

Many Web applications allow data transmission in cleartext format, which is vulnerable to sniffing or Man-In-The-Middle attack. When the data is in cleartext format, the attacker can steal the data:

    from the client’s Web browser
    in transit
    from the server

The developers typically tend to use the HTTP, SMTP, and FTP protocols, which do not offer any kind of encryption. At the same time, the developers may choose to apply a weaker encryption algorithm, which is easy to break. It is also possible that the attacker may also recover the sensitive data from the cache.

As a rule, no confidential data must be stored or transmitted without encryption, which must be up-to-date and uses strong standard algorithms.
Source Code Comments

Developers are always told to comment their code. However, this practice often leads to an application compromise. The developers tend to leave sensitive information, such as security details or design workflows. The comments often help an attacker to gain direction in exploiting the weaknesses, especially when the comments are available in a live Web application.

In a live Web application, you should remove all comments so that there is no hint for the attacker. You should retain the comments in the archived version, which can be used by the new developer or for troubleshooting purposes.
Verbose Errors

Verbose error messages can reveal sensitive details about the application. For example, the error message can reveal the database table names or application’s code structure. When error messages provide more than need to know information, the attacker can get hints about the potential vulnerabilities within the application.

There can be various application errors, such as

    Out of memory
    Null pointer exceptions
    System call failure
    Database unavailable
    Network timeout
    Application timeout

Throwing a detail verbose error message does not help the user. Rather, an attacker will get help from verbose error messages. The developers should display meaningful error messages that could be understood by the users. With a concise and clear error, messages with relevant information will not help the attacker. For example, you, as an attacker, attempt a SQL Injection attack on an application. Even though you do not succeed initially, the error messages provide enough hints about the query logic, which you can use and attempt the SQL Injection attack.
Lack of Error Handling

Lack of proper error handling can lead to various application problems, such as receiving invalid input, corrupting the data, or crashing the application. Consider an example of the Age field. It can accept the input from 1 to 99. There should be an input validation on the field. However, beyond the input handling, there should be an error handling code that handles any unexpected error that may arise. After the input validation, error handling should be used as a second line of defence that prevents a malicious input from exploiting the application from triggering an error condition. In the absence of error handling, it would also be difficult for you to track down the error cause.
Lack of Code Signing

Code signing is a method that is used by the developers to prove that their code is authentic and has not been tempered. If the code is not digitally signed, then a piece of malicious code can be inserted in the original code and delivered to the users. In the absence of code signing, the code lacks two important factors:

    Authenticity: Since the code is not digitally signed, there is no method to prove that the code is authentic. There is no method to compare the malicious code with the authentic code. When users are running the unsigned code, the Web browsers will show the unknown publisher error. The users can never be sure that the code is authentic. Digitally signing the code removes this error.
    Integrity: If there is no code signing, then the integrity of the running code cannot be confirmed. However, if the code is signed and then tempered, the signature will become invalid. Any modification to the signed code then tempers the integrity of the code.

The developers use cryptography to sign the code with a private key digitally. When the user runs the code in the Web browser, it uses the developer’s public key to verify the signature. If the signature is verified, it is ensured that the code is not tampered with and is legitimate.
The Occurrence of Race Conditions

There are certain events in a system that must occur in a sequence. In some cases, the system attempts to perform two or more operations at the same time. However, the design of the system calls for these operations to be done in a sequence. When it is not done in a sequence, the race conditions occur.

The simplest example can be of two threads in an application attempt to change the same set of data at the same time. Both the threads race to access the data. In such a situation, an attacker can take advantage of the time gap, which is the time when the service is triggered, and when a security control uses a thread block situation. Thread block can cause a performance impact on the application in which it occurs.

One method to prevent race condition is by using serialization of memory or storage access. Assume that there are two commands, read and write, that are executed together. You can serialize them by making the read command go first by default and write command later. This method can prevent race conditions.
Hidden Elements - Sensitive Information in the DOM

Developers often use hidden elements on a form. These hidden elements contain information that is usually not relevant to the users. The information from these hidden elements is passed to the Web server. For example, developers might use the hidden field to pass the authentication information to the Web server. Another reason for using the hidden element is to maintain state information. Even though these fields are hidden from the users, you can always view them by viewing the source of the Webpage in which form is loaded.

Just like the users, the attacker can submit the forms to the server. The attacker might submit unexpected values to the server using the hidden fields. This way, the attacker might end up gaining unauthorized entry into the server. When you use fields to maintain state, they can also be accessed by the attacker. Therefore, this can lead to hijack session attack.
